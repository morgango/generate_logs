# Elasticsearch Grok Patterns for Log Parsing

This document provides Grok patterns for parsing all log formats generated by this tool, conforming to Elastic Common Schema (ECS).

## Format Overview

| Format | Identifier | Grok Pattern | ECS Fields |
|--------|------------|--------------|------------|
| Apache | `fmt=apache` | Apache HTTP Access | `@timestamp`, `client.ip`, `http.request.method`, `http.response.status_code` |
| CSV | `fmt=csv` | Comma-delimited | `@timestamp`, `log.level`, `service.name` |
| PIPE | `fmt=pipe` | Pipe-delimited + key=value | `@timestamp`, `log.level`, `service.name`, `transaction.id` |
| KV | `fmt=kv` | Key=value pairs | `@timestamp`, `log.level`, `service.name`, `http.request.id` |
| Hadoop | `fmt=hadoop` | Space-delimited system logs | `@timestamp`, `log.level`, `host.name`, `process.name` |
| Logstash | `fmt=logstash` | Semi-colon delimited | `@timestamp`, `log.level`, `service.name`, `user.id` |
| NGINX | `fmt=nginx` | HTTP Access (NGINX) | `@timestamp`, `client.ip`, `http.request.method`, `http.response.status_code` |
| Tomcat | `fmt=tomcat` | Java Application | `@timestamp`, `log.level`, `process.name`, `log.origin.thread` |
| MySQL | `fmt=mysql` | Database Query | `@timestamp`, `user.name`, `database.name`, `db.query` |
| Redis | `fmt=redis` | Cache/Database | `@timestamp`, `log.level`, `process.pid`, `service.role` |

## Grok Patterns

### 1. Apache HTTP Access Logs
```
%{DATA:format_prefix} %{IPORHOST:client_ip} %{DATA:ident} %{DATA:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:http_method} %{DATA:http_path} %{DATA:http_version}" %{NUMBER:http_response_code:int} %{NUMBER:bytes_sent:int} "%{DATA:http_referer}" "%{DATA:user_agent}" rt=%{NUMBER:response_time:float} upstream=%{DATA:upstream_service}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `client.ip` ← `client_ip`
- `http.request.method` ← `http_method`
- `http.request.uri.original` ← `http_path`
- `http.response.status_code` ← `http_response_code`
- `http.response.bytes` ← `bytes_sent`
- `http.request.referrer` ← `http_referer`
- `user_agent.original` ← `user_agent`
- `event.duration` ← `response_time`
- `service.name` ← `upstream_service`

### 2. CSV Format
```
%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp},%{WORD:log_level},%{DATA:service_name},%{DATA:user_id},%{NUMBER:latency:int},%{NUMBER:status_code:int},%{GREEDYDATA:message}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `log.level` ← `log_level`
- `service.name` ← `service_name`
- `user.id` ← `user_id`
- `event.duration` ← `latency`
- `http.response.status_code` ← `status_code`
- `message` ← `message`

### 3. PIPE Format
```
%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp}\|%{WORD:log_level}\|%{DATA:service_name}\|txn=%{DATA:transaction_id}\|amount=%{NUMBER:amount:float}\|country=%{WORD:country}\|session=%{DATA:session_id}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `log.level` ← `log_level`
- `service.name` ← `service_name`
- `transaction.id` ← `transaction_id`
- `transaction.amount` ← `amount`
- `client.geo.country_iso_code` ← `country`
- `session.id` ← `session_id`

### 4. KV Format
```
%{DATA:format_prefix} ts=%{TIMESTAMP_ISO8601:timestamp} level=%{WORD:log_level} service=%{DATA:service_name} req=%{DATA:request_id} duration_ms=%{NUMBER:duration:int} msg=%{GREEDYDATA:message}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `log.level` ← `log_level`
- `service.name` ← `service_name`
- `http.request.id` ← `request_id`
- `event.duration` ← `duration`
- `message` ← `message`

### 5. Hadoop Format
```
%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{WORD:log_level} %{DATA:component}: %{DATA:hostname} %{DATA:job_id} %{DATA:task_id} memory=%{NUMBER:memory_mb:int} cpu=%{NUMBER:cpu_percent:int} duration=%{NUMBER:duration_ms:int} %{GREEDYDATA:message}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `log.level` ← `log_level`
- `process.name` ← `component`
- `host.name` ← `hostname`
- `process.args` ← `job_id`
- `process.args` ← `task_id`
- `system.memory.total` ← `memory_mb`
- `system.cpu.total.pct` ← `cpu_percent`
- `event.duration` ← `duration_ms`
- `message` ← `message`

### 6. Logstash Format
```
%{DATA:format_prefix} @timestamp=%{TIMESTAMP_ISO8601:timestamp}; level=%{WORD:log_level}; service=%{DATA:service_name}; request_id=%{DATA:request_id}; session_id=%{DATA:session_id}; user_id=%{DATA:user_id}; duration_ms=%{NUMBER:duration:int}; status_code=%{NUMBER:status_code:int}; ip=%{IPORHOST:client_ip}; user_agent=%{DATA:user_agent}; message=%{GREEDYDATA:message}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `log.level` ← `log_level`
- `service.name` ← `service_name`
- `http.request.id` ← `request_id`
- `session.id` ← `session_id`
- `user.id` ← `user_id`
- `event.duration` ← `duration`
- `http.response.status_code` ← `status_code`
- `client.ip` ← `client_ip`
- `user_agent.original` ← `user_agent`
- `message` ← `message`

### 7. NGINX Format
```
%{DATA:format_prefix} %{IPORHOST:client_ip} %{DATA:ident} %{DATA:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:http_method} %{DATA:http_path} %{DATA:http_version}" %{NUMBER:http_response_code:int} %{NUMBER:bytes_sent:int} "%{DATA:http_referer}" "%{DATA:user_agent}" rt=%{NUMBER:response_time:float} upstream=%{DATA:upstream_service}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `client.ip` ← `client_ip`
- `http.request.method` ← `http_method`
- `http.request.uri.original` ← `http_path`
- `http.response.status_code` ← `http_response_code`
- `http.response.bytes` ← `bytes_sent`
- `http.request.referrer` ← `http_referer`
- `user_agent.original` ← `user_agent`
- `event.duration` ← `response_time`
- `service.name` ← `upstream_service`

### 8. Tomcat Format
```
%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{WORD:log_level} %{DATA:component} %{DATA:thread} %{GREEDYDATA:message}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `log.level` ← `log_level`
- `process.name` ← `component`
- `log.origin.thread` ← `thread`
- `message` ← `message`

### 9. MySQL Format
```
%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{DATA:user_name}\[%{DATA:user_name}\] @ %{IPORHOST:host} \[%{TIMESTAMP_ISO8601:query_timestamp}\] %{NUMBER:query_time:float} %{NUMBER:lock_time:float} %{NUMBER:rows_sent:int} %{NUMBER:rows_examined:int} %{DATA:database} %{GREEDYDATA:query}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `user.name` ← `user_name`
- `host.ip` ← `host`
- `event.duration` ← `query_time`
- `event.duration` ← `lock_time`
- `db.rows_sent` ← `rows_sent`
- `db.rows_examined` ← `rows_examined`
- `database.name` ← `database`
- `db.query` ← `query`

### 10. Redis Format
```
%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{WORD:log_level} %{NUMBER:pid:int}:%{DATA:process_type} %{DATA:role} %{GREEDYDATA:message}
```

**ECS Mapping:**
- `@timestamp` ← `timestamp`
- `log.level` ← `log_level`
- `process.pid` ← `pid`
- `service.role` ← `role`
- `message` ← `message`

## Logstash Configuration Example

```ruby
filter {
  # Apache/NGINX HTTP Access Logs
  if [message] =~ /^fmt=(apache|nginx)/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} %{IPORHOST:client_ip} %{DATA:ident} %{DATA:auth} \[%{HTTPDATE:timestamp}\] \"%{WORD:http_method} %{DATA:http_path} %{DATA:http_version}\" %{NUMBER:http_response_code:int} %{NUMBER:bytes_sent:int} \"%{DATA:http_referer}\" \"%{DATA:user_agent}\" rt=%{NUMBER:response_time:float} upstream=%{DATA:upstream_service}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "client.ip" => "%{client_ip}"
        "http.request.method" => "%{http_method}"
        "http.request.uri.original" => "%{http_path}"
        "http.response.status_code" => "%{http_response_code}"
        "http.response.bytes" => "%{bytes_sent}"
        "http.request.referrer" => "%{http_referer}"
        "user_agent.original" => "%{user_agent}"
        "event.duration" => "%{response_time}"
        "service.name" => "%{upstream_service}"
      }
      remove_field => [ "format_prefix", "ident", "auth", "timestamp", "client_ip", "http_method", "http_path", "http_version", "http_response_code", "bytes_sent", "http_referer", "user_agent", "response_time", "upstream_service" ]
    }
  }
  
  # CSV Format
  if [message] =~ /^fmt=csv/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp},%{WORD:log_level},%{DATA:service_name},%{DATA:user_id},%{NUMBER:latency:int},%{NUMBER:status_code:int},%{GREEDYDATA:message}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "log.level" => "%{log_level}"
        "service.name" => "%{service_name}"
        "user.id" => "%{user_id}"
        "event.duration" => "%{latency}"
        "http.response.status_code" => "%{status_code}"
      }
    }
  }
  
  # PIPE Format
  if [message] =~ /^fmt=pipe/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp}\|%{WORD:log_level}\|%{DATA:service_name}\|txn=%{DATA:transaction_id}\|amount=%{NUMBER:amount:float}\|country=%{WORD:country}\|session=%{DATA:session_id}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "log.level" => "%{log_level}"
        "service.name" => "%{service_name}"
        "transaction.id" => "%{transaction_id}"
        "transaction.amount" => "%{amount}"
        "client.geo.country_iso_code" => "%{country}"
        "session.id" => "%{session_id}"
      }
    }
  }
  
  # KV Format
  if [message] =~ /^fmt=kv/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} ts=%{TIMESTAMP_ISO8601:timestamp} level=%{WORD:log_level} service=%{DATA:service_name} req=%{DATA:request_id} duration_ms=%{NUMBER:duration:int} msg=%{GREEDYDATA:message}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "log.level" => "%{log_level}"
        "service.name" => "%{service_name}"
        "http.request.id" => "%{request_id}"
        "event.duration" => "%{duration}"
      }
    }
  }
  
  # Hadoop Format
  if [message] =~ /^fmt=hadoop/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{WORD:log_level} %{DATA:component}: %{DATA:hostname} %{DATA:job_id} %{DATA:task_id} memory=%{NUMBER:memory_mb:int} cpu=%{NUMBER:cpu_percent:int} duration=%{NUMBER:duration_ms:int} %{GREEDYDATA:message}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "log.level" => "%{log_level}"
        "process.name" => "%{component}"
        "host.name" => "%{hostname}"
        "system.memory.total" => "%{memory_mb}"
        "system.cpu.total.pct" => "%{cpu_percent}"
        "event.duration" => "%{duration_ms}"
      }
    }
  }
  
  # Logstash Format
  if [message] =~ /^fmt=logstash/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} @timestamp=%{TIMESTAMP_ISO8601:timestamp}; level=%{WORD:log_level}; service=%{DATA:service_name}; request_id=%{DATA:request_id}; session_id=%{DATA:session_id}; user_id=%{DATA:user_id}; duration_ms=%{NUMBER:duration:int}; status_code=%{NUMBER:status_code:int}; ip=%{IPORHOST:client_ip}; user_agent=%{DATA:user_agent}; message=%{GREEDYDATA:message}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "log.level" => "%{log_level}"
        "service.name" => "%{service_name}"
        "http.request.id" => "%{request_id}"
        "session.id" => "%{session_id}"
        "user.id" => "%{user_id}"
        "event.duration" => "%{duration}"
        "http.response.status_code" => "%{status_code}"
        "client.ip" => "%{client_ip}"
        "user_agent.original" => "%{user_agent}"
      }
    }
  }
  
  # Tomcat Format
  if [message] =~ /^fmt=tomcat/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{WORD:log_level} %{DATA:component} %{DATA:thread} %{GREEDYDATA:message}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "log.level" => "%{log_level}"
        "process.name" => "%{component}"
        "log.origin.thread" => "%{thread}"
      }
    }
  }
  
  # MySQL Format
  if [message] =~ /^fmt=mysql/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{DATA:user_name}\[%{DATA:user_name}\] @ %{IPORHOST:host} \[%{TIMESTAMP_ISO8601:query_timestamp}\] %{NUMBER:query_time:float} %{NUMBER:lock_time:float} %{NUMBER:rows_sent:int} %{NUMBER:rows_examined:int} %{DATA:database} %{GREEDYDATA:query}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "user.name" => "%{user_name}"
        "host.ip" => "%{host}"
        "event.duration" => "%{query_time}"
        "db.rows_sent" => "%{rows_sent}"
        "db.rows_examined" => "%{rows_examined}"
        "database.name" ← "%{database}"
        "db.query" => "%{query}"
      }
    }
  }
  
  # Redis Format
  if [message] =~ /^fmt=redis/ {
    grok {
      match => { 
        "message" => "%{DATA:format_prefix} %{TIMESTAMP_ISO8601:timestamp} %{WORD:log_level} %{NUMBER:pid:int}:%{DATA:process_type} %{DATA:role} %{GREEDYDATA:message}"
      }
    }
    
    mutate {
      add_field => { 
        "@timestamp" => "%{timestamp}"
        "log.level" => "%{log_level}"
        "process.pid" => "%{pid}"
        "service.role" => "%{role}"
      }
    }
  }
}
```

## Elasticsearch Index Template

```json
{
  "index_patterns": ["logs-*"],
  "template": {
    "mappings": {
      "properties": {
        "@timestamp": { "type": "date" },
        "client.ip": { "type": "ip" },
        "http.request.method": { "type": "keyword" },
        "http.request.uri.original": { "type": "text" },
        "http.response.status_code": { "type": "long" },
        "http.response.bytes": { "type": "long" },
        "http.request.referrer": { "type": "keyword" },
        "user_agent.original": { "type": "text" },
        "event.duration": { "type": "float" },
        "service.name": { "type": "keyword" },
        "log.level": { "type": "keyword" },
        "user.id": { "type": "keyword" },
        "transaction.id": { "type": "keyword" },
        "transaction.amount": { "type": "float" },
        "client.geo.country_iso_code": { "type": "keyword" },
        "session.id": { "type": "keyword" },
        "process.name": { "type": "keyword" },
        "host.name": { "type": "keyword" },
        "system.memory.total": { "type": "long" },
        "system.cpu.total.pct": { "type": "float" },
        "log.origin.thread": { "type": "keyword" },
        "user.name": { "type": "keyword" },
        "host.ip": { "type": "ip" },
        "db.rows_sent": { "type": "long" },
        "db.rows_examined": { "type": "long" },
        "database.name": { "type": "keyword" },
        "db.query": { "type": "text" },
        "process.pid": { "type": "long" },
        "service.role": { "type": "keyword" },
        "message": { "type": "text" }
      }
    }
  }
}
```

## Usage Notes

1. **Format Identification**: All patterns start with `fmt=` prefix for easy filtering
2. **ECS Compliance**: All fields map to standard ECS field names
3. **Data Types**: Proper type casting for numbers, dates, and IPs
4. **Flexibility**: Patterns handle variations in log formats
5. **Performance**: Optimized for high-volume log processing

## Testing Patterns

Use the Grok Debugger in Kibana or online tools to test these patterns with sample log data from your log generator.
